import java.io.IOException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;

import javax.naming.CommunicationException;
import javax.naming.Context;
import javax.naming.NamingEnumeration;
import javax.naming.NamingException;
import javax.naming.directory.Attribute;
import javax.naming.directory.Attributes;
import javax.naming.directory.DirContext;
import javax.naming.directory.InitialDirContext;
import javax.naming.directory.SearchControls;
import javax.naming.directory.SearchResult;
import java.util.Date;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Enumeration;
import javax.naming.*;
import javax.naming.ldap.*;

public class KrishADGroupTest{
    
  /*
   * URL of the LDAP server
   */

  public static final String LDAP_URL_DEFAULT = "ldaps://DNJ600C85.NAEAST.AD.JPMORGANCHASE.COM:636";


  /*
   * File path to the location of the SSL keystore to use
   */

  public static final String LDAP_KEYSTORE_DEFAULT = "";

  /*
   * User to bind to the LDAP server with
   */

  public static final String BIND_USER_DEFAULT = "CN=ND-DATAREZ-BINDID1,OU=ND_DATAREZ_CDH,OU=JIS84920,OU=Hadoop Apps,OU=Service Accounts,DC=NAEAST,DC=AD,DC=JPMORGANCHASE,DC=com";

  /*
   * Password for the bind user
  */
  public static final String BIND_PASSWORD_DEFAULT = "jpmis002@";
  


  /*
   * Base distinguished name to use for searches
   */

  public static final String BASE_DN_DEFAULT = "DC=NAEAST,DC=AD,DC=JPMORGANCHASE,DC=com";

  /*
   * Any additional filters to apply when searching for users
   */
 
  public static final String USER_SEARCH_FILTER_DEFAULT = "(&(objectClass=user)(sAMAccountName={0}))";

  /*
   * Any additional filters to apply when finding relevant groups
   */
 
  public static final String GROUP_SEARCH_FILTER_DEFAULT = "(objectClass=group)";

  /*
   * LDAP attribute to use for determining group membership
   */

  public static final String GROUP_MEMBERSHIP_ATTR_DEFAULT = "member";

  /*
   * LDAP attribute to use for identifying a group's name
   */

  public static final String GROUP_NAME_ATTR_DEFAULT = "cn";//"distinguishedName";

  /*
   * LDAP {@link SearchControls} attribute to set the time limit
   * for an invoked directory search. Prevents infinite wait cases.
   */
 
  public static final int DIRECTORY_SEARCH_TIMEOUT_DEFAULT = 10000; // 10s

  
  private static final SearchControls SEARCH_CONTROLS = new SearchControls();
  static {
    SEARCH_CONTROLS.setSearchScope(SearchControls.SUBTREE_SCOPE);
  }

  private DirContext ctx;
  
 
  private static DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");

  public static int RECONNECT_RETRY_COUNT = 3;
  
  /**
   * Returns list of groups for a user.
   * 
   * The LdapCtx which underlies the DirContext object is not thread-safe, so
   * we need to block around this whole method. The caching infrastructure will
   * ensure that performance stays in an acceptable range.
   *
   * @param user get groups for this user
   * @return list of groups for a given user
   */

  public synchronized List<String> getGroups(String user) throws IOException {
    List<String> emptyResults = new ArrayList<String>();
    /*
     * Normal garbage collection takes care of removing Context instances when they are no longer in use. 
     * Connections used by Context instances being garbage collected will be closed automatically.
     * So in case connection is closed and gets CommunicationException, retry some times with new new DirContext/connection. 
     */
    try {
      return doGetGroups(user);
    } catch (CommunicationException e) {
      System.out.println("Connection is closed, will try to reconnect");
      e.printStackTrace();
    } catch (NamingException e) {
      System.out.println("Exception trying to get groups for user " + user + ": "
          + e.getMessage());
      return emptyResults;
    }

    int retryCount = 0;
    while (retryCount ++ < RECONNECT_RETRY_COUNT) {
      //reset ctx so that new DirContext can be created with new connection
      this.ctx = null;
      
      try {
        return doGetGroups(user);
      } catch (CommunicationException e) {
        System.out.println("Connection being closed, reconnecting failed, retryCount = " + retryCount);
      } catch (NamingException e) {
        System.out.println("Exception trying to get groups for user " + user + ":"
            + e.getMessage());
        return emptyResults;
      }
    }
    
    return emptyResults;
  }
  
  List<String> doGetGroups(String user) throws NamingException {
    List<String> groups = new ArrayList<String>();

    DirContext ctx = getDirContext();

    // Search for the user. We'll only ever need to look at the first result
SearchControls searchCtrls = new SearchControls(); searchCtrls.setSearchScope(SearchControls.SUBTREE_SCOPE);
String[] attributes = GROUP_MEMBERSHIP_ATTR_DEFAULT.split(",");

searchCtrls.setReturningAttributes(attributes);

//Change the NameOfGroup for the group name you would like to retrieve the members of.
String filter = "(&" + GROUP_SEARCH_FILTER_DEFAULT + "(" + GROUP_NAME_ATTR_DEFAULT + "={0}))";
//
////use the context we created above and the filter to return all members of a group.
NamingEnumeration values = ctx.search(BASE_DN_DEFAULT, filter, new Object[]{user} ,searchCtrls);
//
////Loop through the search results
 while (values.hasMoreElements()) {
 SearchResult sr = (SearchResult) values.next();  
 Attributes attrs = sr.getAttributes();

  if (null != attrs) {
      for (NamingEnumeration ae = attrs.getAll(); ae.hasMoreElements();){
       Attribute atr = (Attribute) ae.next();
          String attributeID = atr.getID();
             Enumeration vals = atr.getAll();

                while (vals.hasMoreElements()) {
                    String username = (String) vals.nextElement();
                       LdapName ln = new LdapName(username);
                          for(Rdn rdn : ln.getRdns()) {
                            if(rdn.getType().equalsIgnoreCase("CN")) {
                             System.out.println("CN is: " + rdn.getValue());
                               break;
                            }
}
                        
                            }
                             }
                              } else {
                                System.out.println("No members for groups found");  } }

    return groups;
  }

  DirContext getDirContext() throws NamingException {
    if (ctx == null) {
      // Set up the initial environment for LDAP connectivity
      Hashtable<String, String> env = new Hashtable<String, String>();
      env.put(Context.INITIAL_CONTEXT_FACTORY,
          com.sun.jndi.ldap.LdapCtxFactory.class.getName());
      env.put(Context.PROVIDER_URL, LDAP_URL_DEFAULT);
      env.put(Context.SECURITY_AUTHENTICATION, "simple");

      env.put(Context.SECURITY_PRINCIPAL, BIND_USER_DEFAULT);
      env.put(Context.SECURITY_CREDENTIALS, BIND_PASSWORD_DEFAULT);
      ctx = new InitialDirContext(env);
    }

    return ctx;
  }
  

 public static void main(String[] args) {

        MyBackgroudMethod thread = new MyBackgroudMethod();
        //thread.setDaemon(true);
        thread.start();

 }

    private static class MyBackgroudMethod extends Thread {

        @Override
        public void run(){
            while (true) {
                System.out.println("Executed!");
                try {
                    KrishADGroupTest adTest = new KrishADGroupTest();
                    System.out.println(dateFormat.format(new Date())+ " Groups are:: " + adTest.getGroups("ND-POC-ENGINEERS"));
                    Thread.sleep(1*100);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

    }
}

